import os
from io import StringIO

import torch
from string_utils import StringUtils

header_content = """\
/* 
 * auto generated by python
 * model_name: %s
 */
#ifndef DTLN_MODEL_PARAMS_H
#define DTLN_MODEL_PARAMS_H

#include <memory>

const int g_frameLength = %d;
const int g_inputSize = %d;
const int g_hiddenSize = %d;
const int g_encoderSize = %d;

struct DTLN_ModelParams {
%s
    static std::unique_ptr<DTLN_ModelParams> GetInstance();
};

#endif // DTLN_MODEL_PARAMS_H

"""


def write_header(out_header_path, state_dict):
    with open(out_header_path, 'w', encoding='utf8') as fp_header, StringIO() as stream:
        for k, v in state_dict.items():
            name = StringUtils.camel_case(k)
            header_var_names.append(name)
            row_str = f"   const float (*{name})[{' * '.join(map(str, v.shape))}];\n"
            stream.write(row_str)

        fields = stream.getvalue()
        model_name = os.path.basename(in_pt_path)
        fp_header.write(header_content % (model_name, frame_len, input_size, hidden_size, encoder_size, fields))
    print("out_header_path:", out_header_path)
    ...


source_content = """\
/* 
 * auto generated by python
 * model_name: %s
 */
 
#include "%s"

%s
%s
"""

line_content = """\
static const float %s[%s] {
%s
};\n
"""

function_content = """\
std::unique_ptr<DTLN_ModelParams> DTLN_ModelParams::GetInstance() {
    auto modelParams = std::make_unique<DTLN_ModelParams>();

%s
    return modelParams;
}
"""


def get_aligned_str(data, line_max_cnt=10):
    data = data.reshape(-1).astype(str)
    with StringIO() as stream:
        for i in range(0, len(data), line_max_cnt):
            stream.write("    ")
            stream.write("f, ".join(data[i:i + line_max_cnt]))
            stream.write('f,\n')
        return stream.getvalue()


def write_source(out_source_path, state_dict):
    with open(out_source_path, 'w', encoding='utf8') as fp_source, StringIO() as stream1, StringIO() as stream2:
        for k, v in state_dict.items():
            name, shape = "g_" + StringUtils.camel_case(k), ' * '.join(map(str, v.shape))
            source_var_names.append(name)
            value = get_aligned_str(v.numpy())
            line = line_content % (name, shape, value)
            stream1.write(line)

        for hv, sv, in zip(header_var_names, source_var_names):
            stream2.write(f"    modelParams->{hv} = &{sv};\n")

        model_name = os.path.basename(in_pt_path)
        header_name = os.path.basename(out_header_path)
        function = function_content % stream2.getvalue()
        fp_source.write(source_content % (model_name, header_name, stream1.getvalue(), function))
    print("out_source_path:", out_source_path)
    ...


if __name__ == "__main__":
    frame_len, input_size, hidden_size, encoder_size = 1024, 513, 128, 512
    in_pt_path = r"data/models/dtln_ns_d20230721_dnsdrb_trans_hstates_ep200.pth"
    out_header_path = r"data/out_data/DTLN_ModelParams.h"
    out_source_path = r"data/out_data/DTLN_ModelParams.cpp"
    header_var_names, source_var_names = [], []

    state_dict = torch.load(in_pt_path, 'cpu')
    write_header(out_header_path, state_dict)
    write_source(out_source_path, state_dict)
    ...
