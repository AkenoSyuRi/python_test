import os
from io import StringIO

import torch
from string_utils import StringUtils

header_content = """\
/* 
 * auto generated by python
 * model_name: %s
 */
#ifndef GRUC_MODEL_PARAMS_H
#define GRUC_MODEL_PARAMS_H

#include <memory>
#include <fstream>

const int g_inputSize = %d;
const int g_hiddenLayers = %d;
const int g_hiddenUnits = %d;

struct GRUC_ModelParams {
%s
    static std::unique_ptr<GRUC_ModelParams> Load(const std::string &binFilePath) {
        std::ifstream fp(binFilePath, std::ios::in | std::ios::binary);
        if (!fp.is_open()) {
            printf("open file failed: %s\n", binFilePath.c_str());
            abort();
        }

        fp.seekg(0, std::ios::end);
        auto sizeInBytes = (long) fp.tellg();
        fp.seekg(0, std::ios::beg);

        if (sizeof(GRUC_ModelParams) != sizeInBytes) {
            printf("the size of bin file is different to the sizeof(GRUC_ModelParams): %ld, %llu\n",
                   sizeInBytes, sizeof(GRUC_ModelParams));
            abort();
        }

        auto params = std::make_unique<GRUC_ModelParams>();
        fp.read((char *) params.get(), sizeInBytes);
        return params;
    }
};

#endif // GRUC_MODEL_PARAMS_H

"""


def export_params_to(out_header_path, out_binary_path, state_dict):
    with open(out_header_path, "w", encoding="utf8") as fp_header, open(
        out_binary_path, "wb"
    ) as fp_bin, StringIO() as stream:
        for k, v in state_dict.items():
            if any(map(lambda x: x in k, skip_weights_with_names)):
                continue
            name = StringUtils.camel_case(k)
            header_var_names.append(name)
            row_str = f"    float {name}[{' * '.join(map(str, v.shape))}];\n"
            stream.write(row_str)
            fp_bin.write(v.float().numpy().tobytes())

        fields = stream.getvalue()
        model_name = os.path.basename(in_pt_path)
        fp_header.write(
            header_content
            % (model_name, input_size, hidden_layers, hidden_units, fields)
        )
    print("out_header_path:", out_header_path)
    print("out_binary_path:", out_binary_path)
    ...


if __name__ == "__main__":
    input_size, hidden_layers, hidden_units = 513, 3, 300
    in_pt_path = (
        r"../data/models/GRUC/GRUC_0819_wSDR_drb_only_rts_0.25_sin_win_ep67.pth"
    )
    out_header_path = r"../data/out_data/GRUC/GRUC.h"
    out_binary_path = r"../data/out_data/GRUC/GRUC.bin"
    skip_weights_with_names = ["stft", "num_batches_tracked"]
    header_var_names = []

    state_dict = torch.load(in_pt_path, "cpu")
    export_params_to(out_header_path, out_binary_path, state_dict)
    ...
